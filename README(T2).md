# 简单基于块的文件系统设计
## 目标
本任务旨在设计并实现一个简单的基于块的文件系统。通过使用位图和块链表，你将管理文件的存储，并实现基本操作如文件创建与删除、块插入、碎片整理以及状态查看。

## 基本概念
### 块
文件系统中数据存储的最小单位，想象成固定大小的存储空间。文件的数据存储在一个或多个块中。

### 位图
一种用来表示块使用状态的数据结构，用二进制位来指示每个块是否被占用：
- `0` 表示对应的块是空闲的。
- `1` 表示对应的块已被占用。
#### 例如：
假设位图索引范围从`0`到`5`，其中块`1`、`2`和`5`被占用，其余为空闲。

    Index:   0   1   2   3   4   5
    Bitmap: [0] [1] [1] [0] [0] [1]

### 块链表：
记录了文件所占用的块序列，代表文件数据的存储顺序。每个块包含指向下一个块的索引。最后一个块的“下一个块索引”为`-1`，表示链表结束。在本作业中，我们使用数组来模拟块链表。如果你熟悉链表的概念，可以自由地实现一个。

#### 例如：
文件从块1开始，占用了块索引`1`、`3`、`5`。
- 块链表数组表示如下：

        Index:    0   1   2   3   4   5
        Content:[-1] [3][-1] [5][-1][-1]

- 块链链表表示为：

        [Block 1] -> [Block 3] -> [Block 5] -> -1

## 系统设计
### 初始化 (INIT)
程序启动后，输入一个整数指定文件系统中的总块数。根据总块数创建一个位图，并将所有位初始化为`0`。系统维护一个文件列表，记录每个文件的名称及其对应的块链表起始块。

### 创建文件 (CREATE)
以指定的文件名和所需的块数创建文件。分配必要的块，设置位图中相应的位为`1`，并按顺序链接分配的块形成块链表。将新文件的名称和起始块添加到文件列表中。

### 删除文件 (DELETE)
删除指定的文件，释放文件占用的块，更新位图，并从文件列表中移除该文件。

### 追加块 (APPEND)
向指定文件的末尾追加指定数量的块。分配必要的块，更新位图，并将新分配的块链接到文件块链表的末尾。

### 碎片整理 (DEFRAG)
由于频繁对文件块的操作，文件的块链表容易变得碎片化（非连续块索引），影响读写效率。碎片整理操作采用“紧凑碎片整理”方法重新组织文件的块链表，即尽可能向前移动所有文件的块，使空闲块集中在后面。这提高了文件系统的性能。

#### 例如：
整理前：
- 位图状态：

        Index:     0    1   2    3    4    5
        Bitmap:   [1]  [0] [1]  [0]  [1]  [1]
        Block LL: [2] [-1] [4] [-1] [-1] [-1]

- 文件`file1`的块链表是`[Block 0] -> [Block 2] -> [Block 4] -> -1`。
- 文件`file2`的块链表是`[Block 5]->-1`。

整理后：
- 位图状态：
- 文件`file1`的块链表更新为`[Block 0] -> [Block 1] -> [Block 2] -> -1`。
- 文件`file2`的块链表更新为`[Block 3] -> -1`。
### 显示状态 (STATUS)
显示文件系统的当前状态，包括每个文件的名称及其对应的块链表。输出格式为：`<filename> [<block index 1> <block index 2> ... -1]`。

### 退出程序 (QUIT)
退出文件系统程序。

### 块分配策略
为了简化设计，我们采取每次分配一个块的策略，按照它们索引的顺序分配。实际文件系统中通常会使用更复杂的分配策略，比如首次适应、最佳适应、最差适应等。如果你感兴趣，可以进一步探索这些主题。

## 输入和输出格式
首行输入`INIT`操作，随后是一个整数表示文件系统中的总块数`N` `(5<= N <= 500)`。后续输入是一系列命令直到输入`QUIT`为止。

### 命令格式
- `CREATE <filename> <number of blocks>`
    - 如果文件名已经存在，输出`<filename> EXISTED`
    - 如果可用的系统块不足，则输出`<filename> INSUFFICIENT BLOCKS`
- `DELETE <filename>`
    - 如果文件不存在，输出`<filename> NOT FOUND`
- `APPEND <filename> <number of blocks>`
    - 如果文件不存在，输出`<filename> NOT FOUND`
    - 如果可用的系统块不足，则输出`<filename> INSUFFICIENT BLOCKS`
- `DEFRAG`
    - 重新排列文件块，以集中所有文件的块向前和自由块在后面。
- `STATUS`
    - 按照创建顺序输出文件。
    - 输出格式：`<filename> [<block index 1> <block index 2> ... -1]`。
    - 如果文件没有块，则输出`<filename> [-1]`。
    - 如果文件数为0，则输出`EMPTY`
- `QUIT`
    - 退出程序
#### 注意事项
- 所有输入都是有效格式；无需检查无效输入。
- 文件名不超过10个字符且不含特殊字符。
- 块的数量是非负整数`（>=0）`。
- 创建的文件总数不超过`100`。
### 示例
#### 样例输入1：
    INIT 5 
    CREATE file1 1 
    CREATE file2 2 
    STATUS 
    APPEND file1 1 
    DELETE file2 
    CREATE file2 1 
    APPEND file1 2 
    STATUS DEFRAG 
    STATUS QUIT
#### 样例输出1：
    file1 [0 -1] 
    file2 [1 2 -1] 
    file1 [0 3 2 4 -1] 
    file2 [1 -1] 
    file1 [0 1 2 3 -1] 
    file2 [4- 1]
#### 样例输入2：
    INIT 5
    CREATE file1 10
    STATUS
    APPEND file1 1
    CREATE file1 5
    DELETE file1
    CREATE file1 0
    STATUS
    QUIT
#### 样例输出2：
    file1 INSUFFICIENT BLOCKS
    EMPTY
    file1 NOT FOUND
    file1 [-1]

## 示例代码
提供的示例代码仅供参考实现。你可以根据自己的逻辑进行实现或修改。
